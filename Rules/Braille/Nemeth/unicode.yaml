---
# To greatly simplify typeface/language generation, the chars have unique ASCII chars for them:
# Typeface: S: sans-serif, B: bold, T: script/blackboard, I: italic, R: Roman
# Language: E: English, D: German, G: Greek, V: Greek variants, H: Hebrew, U: Russian
# Indicators: C: capital, L: letter, N: number, P: punctuation, M: multipurpose
# Others: W -- whitespace that should be kept (e.g, in a numeral)
#  SRE doesn't have H: Hebrew or U: Russian, so not encoded (yet)
# Some of the weird letters (e.g., circled letters) I didn't translate with the above because
#   they don't interact with rules since they are enclosed in other chars.


  # --- Nemeth Default Alphabet normal chars. ---
 - "0": [t: "N⠴"]               # 0x30
 - "1": [t: "N⠂"]               # 0x31
 - "2": [t: "N⠆"]               # 0x32
 - "3": [t: "N⠒"]               # 0x33
 - "4": [t: "N⠲"]               # 0x34
 - "5": [t: "N⠢"]               # 0x35
 - "6": [t: "N⠖"]               # 0x36
 - "7": [t: "N⠶"]               # 0x37
 - "8": [t: "N⠦"]               # 0x38
 - "9": [t: "N⠔"]               # 0x39
 - "A": [t: "CL⠁"]              # 0x41
 - "B": [t: "CL⠃"]              # 0x42
 - "C": [t: "CL⠉"]              # 0x43
 - "D": [t: "CL⠙"]              # 0x44
 - "E": [t: "CL⠑"]              # 0x45
 - "F": [t: "CL⠋"]              # 0x46
 - "G": [t: "CL⠛"]              # 0x47
 - "H": [t: "CL⠓"]              # 0x48
 - "I": [t: "CL⠊"]              # 0x49
 - "J": [t: "CL⠚"]              # 0x4a
 - "K": [t: "CL⠅"]              # 0x4b
 - "L": [t: "CL⠇"]              # 0x4c
 - "M": [t: "CL⠍"]              # 0x4d
 - "N": [t: "CL⠝"]              # 0x4e
 - "O": [t: "CL⠕"]              # 0x4f
 - "P": [t: "CL⠏"]              # 0x50
 - "Q": [t: "CL⠟"]              # 0x51
 - "R": [t: "CL⠗"]              # 0x52
 - "S": [t: "CL⠎"]              # 0x53
 - "T": [t: "CL⠞"]              # 0x54
 - "U": [t: "CL⠥"]              # 0x55
 - "V": [t: "CL⠧"]              # 0x56
 - "W": [t: "CL⠺"]              # 0x57
 - "X": [t: "CL⠭"]              # 0x58
 - "Y": [t: "CL⠽"]              # 0x59
 - "Z": [t: "CL⠵"]              # 0x5a
 - "a": [t: "L⠁"]               # 0x61
 - "b": [t: "L⠃"]               # 0x62
 - "c": [t: "L⠉"]               # 0x63
 - "d": [t: "L⠙"]               # 0x64
 - "e": [t: "L⠑"]               # 0x65
 - "f": [t: "L⠋"]               # 0x66
 - "g": [t: "L⠛"]               # 0x67
 - "h": [t: "L⠓"]               # 0x68
 - "i": [t: "L⠊"]               # 0x69
 - "j": [t: "L⠚"]               # 0x6a
 - "k": [t: "L⠅"]               # 0x6b
 - "l": [t: "L⠇"]               # 0x6c
 - "m": [t: "L⠍"]               # 0x6d
 - "n": [t: "L⠝"]               # 0x6e
 - "o": [t: "L⠕"]               # 0x6f
 - "p": [t: "L⠏"]               # 0x70
 - "q": [t: "L⠟"]               # 0x71
 - "r": [t: "L⠗"]               # 0x72
 - "s": [t: "L⠎"]               # 0x73
 - "t": [t: "L⠞"]               # 0x74
 - "u": [t: "L⠥"]               # 0x75
 - "v": [t: "L⠧"]               # 0x76
 - "w": [t: "L⠺"]               # 0x77
 - "x": [t: "L⠭"]               # 0x78
 - "y": [t: "L⠽"]               # 0x79
 - "z": [t: "L⠵"]               # 0x7a
 - "Α": [t: "GCL⠁"]             # 0x391
 - "Β": [t: "GCL⠃"]             # 0x392
 - "Γ": [t: "GCL⠛"]             # 0x393
 - "Δ": [t: "GCL⠙"]             # 0x394
 - "Ε": [t: "GCL⠑"]             # 0x395
 - "Ζ": [t: "GCL⠵"]             # 0x396
 - "Η": [t: "GCL⠱"]             # 0x397
 - "Θ": [t: "GCL⠹"]             # 0x398
 - "Ι": [t: "GCL⠊"]             # 0x399
 - "Κ": [t: "GCL⠅"]             # 0x39a
 - "Λ": [t: "GCL⠇"]             # 0x39b
 - "Μ": [t: "GCL⠍"]             # 0x39c
 - "Ν": [t: "GCL⠝"]             # 0x39d
 - "Ξ": [t: "GCL⠭"]             # 0x39e
 - "Ο": [t: "GCL⠕"]             # 0x39f
 - "Π": [t: "GCL⠏"]             # 0x3a0
 - "Ρ": [t: "GCL⠗"]             # 0x3a1
 - "ϴ": [t: "GCL⠹"]             # 0x3f4
 - "Σ": [t: "GCL⠎"]             # 0x3a3
 - "Τ": [t: "GCL⠞"]             # 0x3a4
 - "Υ": [t: "GCL⠥"]             # 0x3a5
 - "Φ": [t: "GCL⠋"]             # 0x3a6
 - "Χ": [t: "GCL⠯"]             # 0x3a7
 - "Ψ": [t: "GCL⠽"]             # 0x3a8
 - "Ω": [t: "GCL⠺"]             # 0x3a9
 - "∇": [t: "GL⠫"]              # 0x2207
 - "α": [t: "GL⠁"]              # 0x3b1
 - "β": [t: "GL⠃"]              # 0x3b2
 - "γ": [t: "GL⠛"]              # 0x3b3
 - "δ": [t: "GL⠙"]              # 0x3b4
 - "ε": [t: "GL⠑"]              # 0x3b5
 - "ζ": [t: "GL⠵"]              # 0x3b6
 - "η": [t: "GL⠱"]              # 0x3b7
 - "θ": [t: "GL⠹"]              # 0x3b8
 - "ι": [t: "GL⠊"]              # 0x3b9
 - "κ": [t: "GL⠅"]              # 0x3ba
 - "λ": [t: "GL⠇"]              # 0x3bb
 - "μ": [t: "GL⠍"]              # 0x3bc
 - "ν": [t: "GL⠝"]              # 0x3bd
 - "ξ": [t: "GL⠭"]              # 0x3be
 - "ο": [t: "GL⠕"]              # 0x3bf
 - "π": [t: "GL⠏"]              # 0x3c0
 - "ρ": [t: "GL⠗"]              # 0x3c1
 - "ς": [t: "VL⠎"]              # 0x3c2
 - "σ": [t: "GL⠎"]              # 0x3c3
 - "τ": [t: "GL⠞"]              # 0x3c4
 - "υ": [t: "GL⠥"]              # 0x3c5
 - "φ": [t: "VL⠋"]              # 0x3c6
 - "χ": [t: "GL⠯"]              # 0x3c7
 - "ψ": [t: "GL⠽"]              # 0x3c8
 - "ω": [t: "GL⠺"]              # 0x3c9
 - "∂": [t: "⠈⠙"]               # 0x2202
 - "ϵ": [t: "GL⠑"]              # 0x3f5
 - "ϑ": [t: "VL⠹"]              # 0x3d1
 - "ϰ": [t: "GL⠅"]              # 0x3f0
 - "ϕ": [t: "GL⠋"]              # 0x3d5
 - "ϱ": [t: "GL⠗"]              # 0x3f1
 - "ϖ": [t: "GL⠏"]              # 0x3d6


  # --- Nemeth Default Characters math_symbols chars. ---
 - "\"": [t: "⠄⠄"]              # 0x22
 - "#": [t: "⠨⠼"]               # 0x23
 - "$": [t: "⠈⠎"]               # 0x24
 - "%": [t: "⠈⠴"]               # 0x25
 - "&": [t: "⠸⠯"]               # 0x26
 - "*": [t: "⠈⠼"]               # 0x2a
 - "+": [t: "⠬"]                # 0x2b
 - "/": [t: "⠸⠌"]               # 0x2f
 - "<": [t: "⠐⠅"]               # 0x3c
 - "=": [t: "⠨⠅"]               # 0x3d
 - ">": [t: "⠨⠂"]               # 0x3e
 - "@": [t: "⠈⠁"]               # 0x40
 - "\\": [t: "⠸⠡"]              # 0x5c
 - "^": [t: "⠸⠣"]               # 0x5e
 - "`": [t: "⠈"]                # 0x60
 - "≟": [t: "⠐⠨⠅⠣⠸⠦⠻"]          # 0x225f
 - "≠": [t: "⠌⠨⠅"]              # 0x2260
 - "≡": [t: "⠸⠇"]               # 0x2261
 - "≤": [t: "⠐⠅⠱"]              # 0x2264
 - "≥": [t: "⠨⠂⠱"]              # 0x2265
 - "⊂": [t: "⠸⠐⠅"]              # 0x2282
 - "⊃": [t: "⠸⠨⠂"]              # 0x2283
 - "⊄": [t: "⠌⠸⠐⠅"]             # 0x2284
 - "⊅": [t: "⠌⠸⠨⠂"]             # 0x2285
 - "⊆": [t: "⠸⠐⠅⠱"]             # 0x2286
 - "⊇": [t: "⠸⠨⠂⠱"]             # 0x2287
 - "⊥": [t: "⠫⠏"]               # 0x22a5
 - "⋀": [t: "⠈⠩"]               # 0x22c0
 - "⋁": [t: "⠈⠬"]               # 0x22c1
 - "⋂": [t: "⠨⠩"]               # 0x22c2
 - "⋃": [t: "⠨⠬"]               # 0x22c3
 - "⋅": [t: "⠡"]                # 0x22c5
 - "⋜": [t: "⠱⠐⠅"]              # 0x22dc
 - "⋝": [t: "⠱⠨⠂"]              # 0x22dd
 - "⋮": [t: "⠣⠄⠄⠄"]             # 0x22ee
 - "⋯": [t: "⠄⠄⠄"]              # 0x22ef
 - "⋰": [t: "⠘⠄⠄⠄"]             # 0x22f0
 - "⋱": [t: "⠰⠄⠄⠄"]             # 0x22f1

  # --- Nemeth Default Characters rest chars. ---
 - "←": [t: "⠫⠪⠒⠒"]             # 0x2190
 - "ⅆ": [t: "⠙"]                # 0x2146
 - "ⅇ": [t: "⠑"]                # 0x2147
 - "(": [t: "⠷"]                # 0x28
 - ")": [t: "⠾"]                # 0x29
 - "[": [t: "⠈⠷"]               # 0x5b
 - "]": [t: "⠈⠾"]               # 0x5d
 - "{": [t: "⠨⠷"]               # 0x7b
 - "}": [t: "⠨⠾"]               # 0x7d
 - "⌈": [t: "⠈⠘⠷"]              # 0x2308
 - "⌉": [t: "⠈⠘⠾"]              # 0x2309
 - "⌊": [t: "⠈⠰⠷"]              # 0x230a
 - "⌋": [t: "⠈⠰⠾"]              # 0x230b


 # overwrites from MS
   # space inside of numbers has special treatment
 - " ":                        # 0x20 (space)
    - test:
        if: "self::m:mn"
        then: [t: "⠀"]
        else: [t: "W"]

 - " ":                        # 0xA0 (non-breaking space)
    - test:
        if: "self::m:mn"
        then: [t: "⠀"]
        else: [t: "W"]
 - "!":                          # 0x21 (Factorial)
    - test:
        if: "self::m:mo"
        then: [t: "⠯"]
        else: [t: "P⠖"]

#  - "\"": [t: ""]                # 0x22 (Quotation mark)
 - "#": [t: "⠨⠼"]               # 0x23 (Number sign)
 - "$": [t: "⠈⠎"]               # 0x24 (Dollar sign)
 - "%": [t: "⠈⠴"]               # 0x25 (Percent sign)
 - "&": [t: "⠸⠯"]               # 0x26 (Ampersand)
 - "'": [t: "P⠄"]                # 0x27 (Apostrophe)
 - "(": [t: "⠷"]                # 0x28 (Left parenthesis)
 - ")": [t: "⠾"]                # 0x29 (Right parenthesis)
 - "*": [t: "⠈⠼"]               # 0x002A (Asterisk)
 - "+": [t: "⠬"]                # 0x002B (Plus sign)
 - ",":                         # 0x002C (Comma)
    - test:
          # test if first ancestor that isn't an mrow is a script tag (rule 78)
      - if: "self::m:mn"
        then: [t: "⠠"]
      - else_if: "ancestor-or-self::*[not(parent::m:mrow)][1][parent::m:msub or parent::m:msup or parent::m:msubsup or parent::m:mmultiscripts][preceding-sibling::*]"
        then: [t: "⠪"]        # Rule 78
        else: [t: ","]        # ',' used for matching purposes, converted to "⠠⠀"
 - "-":                         # 0x002D (Hyphen)  (0x2212 normalized to here)
    - test:
        if: "self::m:mtext"
        then: [t: "P⠤"]
        else: [t: "⠤"]

 - ".":                          # 0x002E (Full stop or decimal pt)
      # '.' is particularly tricky because we need to know if it is really numeric or not.
      # if it is numeric, it might be a on it's own or part of a number.
      # normally, it is merged with the digits if part of a number, but if the adjacent digit(s) are modified
      #  by something (e.g., a bar over the digit to signify that it repeats), then it is really part of the number
      # If it is the last part of the expr, then it is punctuation (for typographic reasons, punctuation is often included in the math)
    - test:
        if: "self::m:mn or (self::m:mo and following-sibling::*)"
        then_test:
          if: "string-length(text()) = 1 and not(
                  following-sibling::*[1][BaseNode(.)[self::m:mn]] or
                  following-sibling::*[1][self::m:menclose and @notation='top' and *[1][self::m:mn]]
              )"
          then: [t: "𝑁⠨"]      # example 8c(4) -- lone "." is not considered numeric, but not a period
          else: [t: "N⠨"]
        else: [t: "P⠲"]         # period
 - "/": [t: "⠸⠌"]               # 0x002F (Solidus)
 - ":":                         # 0x003A (Colon)
        # sometimes a colon is meant to be a ratio
        # this test is based on what SRE does -- if the "roles" are the same, it guesses "ratio"
        # MathCAT doesn't have roles, so we do a hack that looks checks mrows if not atomic.
        # If an mrow, guess it is infix and checks the operator. This is pretty weak!
        # Need to rule out field extensions "[K:F]" and trilinear coordinates "a:b:c" as they use the punctuation form
    - test:
        if: "not(IsBracketed(ancestor::*[2], '[', ']')) and
             not( preceding-sibling::*[2][text()=':'] or following-sibling::*[2][text()=':']) and 
             name(preceding-sibling::*[1]) = name(following-sibling::*[1]) and
             ( name(preceding-sibling::*[1]) != 'mrow' or
               (preceding-sibling::*[1]/*[2][text()] = following-sibling::*[1]/*[2][text()]) )"
        then: [t: "W⠐⠂W"]
        else: [t: "P⠒W"]
 - ";": [t: "P⠆"]               # 0x003B (Semicolon)
 - "<": [t: "⠐⠅"]             # 0x003C (Less-than sign)
 - "=": [t: "⠨⠅"]             # 0x003D (Equals sign)
 - ">": [t: "⠨⠂"]             # 0x003E (Greater-than sign)
 - "?": [t: "P⠦"]               # 0x003F (Question mark)
 - "@": [t: "⠈⠁"]               # 0x40 (Commercial at)
 - "[": [t: "⠈⠷"]               # 0x005B (Left square bracket)
 - "\\": [t: "⠸⠡"]              # 0x005C (Reverse solidus)
 - "]": [t: "⠈⠾"]               # 0x005D (Right square bracket)
 - "^": [t: "⠸⠣"]               # 0x005E (Circumflex accent)
 - "_": [t: ""]                 # 0x005F (Low line)
 - "{": [t: "⠨⠷"]               # 0x007B (Left curly bracket)
 - "|":                # 0x007C (Vertical line)
     - test:
        if: "preceding-sibling::* and following-sibling::*"
        then: [t: "W⠳W"]        # comparison (e.g., such that -- rule 145)
        else: [t: "⠳"]          # absolute value, others???
 - "}": [t: "⠨⠾"]               # 0x007D (Right curly bracket)
 - "~": [t: "⠈⠱"]               # 0x007E (Tilde)
 - "¢": [t: "⠈⠉"]               # 0x00A2 (Cent sign)
 - "£": [t: "⠈⠇"]               # 0x00A3 (Pound sterling)
 - "§": [t: "⠈⠠⠎"]              # 0x00A7 (Section sign)
 - "©": [t: "⠷⠠⠉⠾"]             # 0x00A9 (Copyright sign)
 - "¬": [t: ""]                 # 0x00AC (Not sign)
 - "¯": [t: "⠱"]                # 0x00AF (bar)
 - "°": [t: "⠨⠡"]              # 0x00B0 (Degree sign)
 - "±": [t: "⠬⠤"]               # 0x00B1 (Plus-minus sign)
 - "¶": [t: "⠈⠠⠏"]              # 0x00B6 (Pilcrow sign)
 - "·": [t: "⠡"]                # 0x00B7 (Middle dot)
 - "×": [t: "⠈⠡"]               # 0x00D7 (Multiplication sign)
 - "÷": [t: "⠨⠌"]               # 0x00F7 (Division sign)
      # rule 43b about spaces (references rule 42)
      # tests are ugly because an invisible times might have been inserted and we need to skip that
 - "—": [t: "⠤⠤"]               # 0x2014 (Em dash)
 - "―":                          # 0x2015 (Horizontal bar)
    - test:
        if:
          - "preceding-sibling::* and"
          - "not("
          - "  preceding-sibling::*[1][ "
          - "    (text() != '\u2062' and (IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols') or IsInDefinition(., 'NemethCurrencyBeforeSymbols')) ) or "
          - "    (text() = '\u2062' and preceding-sibling::* and "
          - "       preceding-sibling::*[2][IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols') or IsInDefinition(., 'NemethCurrencyBeforeSymbols')] "
          - "    ) ] )"
        then: [t: "W"]
    - t: "⠤⠤⠤⠤"
    - test:
        if:
          - "not("
          - "  following-sibling::* and "
          - "  following-sibling::*[1][ "
          - "    (text() != '\u2062' and (IsInDefinition(., 'NemethPunctAndOpenAfterSymbols') or IsInDefinition(., 'NemethCurrencyAfterSymbols'))) or "
          - "    (text() = '\u2062' and following-sibling::* and "
          - "       following-sibling::*[2][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols') or IsInDefinition(., 'NemethCurrencyAfterSymbols')] "
          - "    ) ]  )"
        then: [t: "W"]

 - "…":                          # 0x2026 (Ellipsis)
      # rule 43b about spaces (references rule 42); partly superseded by lesson 2.13
      # tests are ugly because an invisible times might have been inserted and we need to skip that
    - test:
        if:
          - "not("
          - "  preceding-sibling::* and "
          - "  preceding-sibling::*[1][ "
          - "    (text() != '\u2062' and (IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols') or IsInDefinition(., 'NemethCurrencyBeforeSymbols'))) or "
          - "    (text() = '\u2062' and preceding-sibling::* and "
          - "       preceding-sibling::*[2][IsInDefinition(., 'NemethPunctAndOpenBeforeSymbols') or IsInDefinition(., 'NemethCurrencyBeforeSymbols')] "
          - "    ) ] )"
        then: [t: "W"]
    - t: "⠄⠄⠄"
    - test:
        if:
          - "not("
          - "  following-sibling::* and "
          - "  following-sibling::*[1][ "
          - "    (text() != '\u2062' and (IsInDefinition(., 'NemethPunctAndOpenAfterSymbols') or IsInDefinition(., 'NemethCurrencyAfterSymbols'))) or "
          - "    (text() = '\u2062' and following-sibling::* and "
          - "       following-sibling::*[2][IsInDefinition(., 'NemethPunctAndOpenAfterSymbols') or IsInDefinition(., 'NemethCurrencyAfterSymbols')] "
          - "    ) ]  )"
        then: [t: "W"]
 - "‰": [t: "`00"]
 - "′": [t: "⠄"]                # 0x2032 (Prime)
 - "″": [t: "⠄⠄"]               # 0x2033 (Double prime)
 - "⁡":                         # 0x2061⁡ (invisible function apply)
    # add a space if name doesn't have brackets after it or is in FunctionNames list 
    - test:
        if: "not(following-sibling::*[1][IsBracketed(., '', '')]) or preceding-sibling::*[1][IsInDefinition(BaseNode(.), 'FunctionNames')]" 
        then: [t: "W"]
 - "⁢": [t: ""]                  # 0x2062 -- what's right???  "⠈⠡" (times) is not right
 - "⁣":                         # 0x2063 (Invisible Comma -- treat like a normal comma when in a subscript[issue #40]) else ignore
    - test:
          # test if first ancestor that isn't an mrow is a script tag (rule 78)
      - if: "self::m:mn"
        then: [t: ""]
      - else_if: "ancestor-or-self::*[not(parent::m:mrow)][1][parent::m:msub or parent::m:msup or parent::m:msubsup or parent::m:mmultiscripts][preceding-sibling::*]"
        then: [t: "⠪"]        # Rule 78
        else: [t: ""]
 - "⁤": [t: ""]                 # 0x2064

 - "ℏ": [t: "⠈⠓"]               # 0x210F (Planck constant over two pi)
 - "ℓ": [t: "TE⠇"]               # 0x2113 (Script small l (differs from 1d4c1: 4-56-123))
 - "→":                           # 0x2192 (Rightwards arrow)
     - test:                      # Rule 96 -- uncontracted form if base of under/over
        if: "not(preceding-sibling::*) and parent::*[self::m:mover or self::m:munder or self::m:munderover]"
        then: [t: "⠫⠒⠒⠕"]        # uncontracted version
        else: [t: "⠫⠕"]        # contracted version
 - "∀": [t: "⠈⠯"]               # 0x2200 (For all)
 - "∂": [t: "⠈⠙"]               # 0x2202 (Partial differential)
 - "∃": [t: "⠈⠿"]               # 0x2203 (There exists)
 - "∄": [t: "⠌⠈⠿"]              # 0x2204 (There does not exist)
 - "∅": [t: "⠸⠴"]               # 0x2205 (Empty set)
 - "∑": [t: "⠨⠠⠎"]              # 0x2211 (N-ary summation)
 - "∞": [t: "⠠⠿"]               # 0x221E (Infinity)
 - "∟": [t: "⠫⠪⠨⠗⠻"]            # 0x221F (Right angle)
 - "∠": [t: "⠫⠪"]               # 0x2220 (Angle)
 - "∡": [t: "⠫⠪⠈⠫⠁⠻"]           # 0x2221 (Measured angle)
 - "∣": [t: "⠳"]              # 0x2223 (Divides)
 - "∤": [t: "⠌⠳"]             # 0x2224 (Does not divide)
 - "∧": [t: "⠈⠩"]               # 0x2227 (Logical AND)
 - "∨": [t: "⠈⠬"]               # 0x2228 (Logical OR)
 - "∩": [t: "⠨⠩"]               # 0x2229 (Intersection)
 - "∪": [t: "⠨⠬"]               # 0x222A (Union)
 - "∫": [t: "⠮"]                # 0x222B (Integral)
 - "∬": [t: "⠮⠮"]               # 0x222C (Double integral)
 - "⌈": [t: "⠈⠘⠷"]              # 0x2308 (Left ceiling)
 - "⌉": [t: "⠈⠘⠾"]              # 0x2309 (Right ceiling)
 - "⌊": [t: "⠈⠰⠷"]              # 0x230A (Left floor)
 - "⌋": [t: "⠈⠰⠾"]              # 0x230B (Right floor)
